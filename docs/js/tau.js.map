{"version":3,"names":[],"mappings":"","sources":["src/js/tau.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, THREE, WEBVR */\n\nimport { ROOM_RADIUS, TEST_ENABLED } from './three/const';\nimport InteractiveMesh from './three/interactive.mesh';\nimport Orbit from './three/orbit';\n\nclass Tau {\n\n\tconstructor() {\n\t\tthis.count = 0;\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.cameraDirection = new THREE.Vector3();\n\t\tthis.init();\n\t}\n\n\t/*\n\tload(jsonUrl) {\n\t\ttry {\n\t\t\tfetch(jsonUrl).then(response => response.json()).then(response => {\n\t\t\t\tthis.pivot.views = response.views;\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\t*/\n\n\tinit() {\n\t\tconst body = this.body = document.querySelector('body');\n\t\tconst section = this.section = document.querySelector('.tau');\n\t\tconst container = this.container = section.querySelector('.tau__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\t\tconst debugSave = this.debugSave = section.querySelector('.debug__save');\n\t\t// Dom.detect(body);\n\t\t// body.classList.add('ready');\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onKeyDown = this.onKeyDown.bind(this);\n\t\tthis.onMouseDown = this.onMouseDown.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t\tthis.onMouseWheel = this.onMouseWheel.bind(this);\n\t\tthis.onSave = this.onSave.bind(this);\n\t\t//\n\t\tconst scene = this.scene = this.addScene();\n\t\tconst camera = this.camera = this.addCamera();\n\t\tconst lights = this.lights = this.addLights(scene);\n\t\tconst boxes = this.boxes = this.addBoxes(scene);\n\t\tconst tau = this.tau = this.addTau(scene);\n\t\tconst renderer = this.renderer = this.addRenderer();\n\t\t// camera.target.z = ROOM_RADIUS;\n\t\tcamera.lookAt(camera.target);\n\t\tconst controls = this.controls = new THREE.OrbitControls(camera, renderer.domElement);\n\t\tcamera.position.set(-50, 80, 100);\n\t\tcontrols.update();\n\t\tconst orbit = this.orbit = new Orbit();\n\t\tconst dragListener = this.dragListener = orbit.setDragListener(container);\n\t\t// raycaster\n\t\tconst raycaster = this.raycaster = new THREE.Raycaster();\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\twindow.addEventListener('keydown', this.onKeyDown, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\t\tdocument.addEventListener('wheel', this.onMouseWheel, false);\n\t\tthis.container.addEventListener('mousedown', this.onMouseDown, false);\n\t\tthis.container.addEventListener('mouseup', this.onMouseUp, false);\n\t\tthis.debugSave.addEventListener('click', this.onSave, false);\n\t\tthis.section.classList.add('init');\n\t\tthis.onWindowResize();\n\t}\n\n\taddRenderer() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t\tlocalClippingEnabled: true,\n\t\t\t// logarithmicDepthBuffer: true,\n\t\t\tpremultipliedAlpha: true,\n\t\t\talpha: true,\n\t\t});\n\t\tthis.renderer = renderer;\n\t\t// renderer.shadowMap.enabled = true;\n\t\trenderer.setClearColor(0xffffff, 1);\n\t\trenderer.setPixelRatio(2); // window.devicePixelRatio);\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\t\treturn renderer;\n\t}\n\n\taddScene() {\n\t\tconst scene = new THREE.Scene();\n\t\t// scene.background = new THREE.Color(0x00000000);\n\t\t// scene.background = new THREE.Color(0x404040);\n\t\t// scene.fog = new THREE.Fog(scene.background, 10, 700);\n\t\treturn scene;\n\t}\n\n\taddCamera() {\n\t\tconst camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, ROOM_RADIUS * 2);\n\t\tcamera.target = new THREE.Vector3();\n\t\treturn camera;\n\t}\n\n\taddLights(scene) {\n\t\t/*\n\t\tconst hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);\n\t\themiLight.color.setHSL(0.6, 1, 0.6);\n\t\themiLight.groundColor.setHSL(0.095, 1, 0.75);\n\t\themiLight.position.set(0, 50, 0);\n\t\tscene.add(hemiLight);\n\t\t*/\n\t\t/*\n\t\tconst hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 10);\n\t\tscene.add(hemiLightHelper);\n\t\t*/\n\t\tconst dirLight = new THREE.DirectionalLight(0xffffff, 1);\n\t\tdirLight.color.setHSL(0.1, 1, 0.95);\n\t\tdirLight.position.set(-30, 40, 30);\n\t\tscene.add(dirLight);\n\n\t\tconst dirLight2 = new THREE.DirectionalLight(0xffffff, 1);\n\t\tdirLight2.color.setHSL(0.1, 1, 0.95);\n\t\tdirLight2.position.set(30, 40, -30);\n\t\tscene.add(dirLight2);\n\t\t/*\n\t\tdirLight.castShadow = true;\n\t\tdirLight.shadow.mapSize.width = 2048;\n\t\tdirLight.shadow.mapSize.height = 2048;\n\t\tconst d = 50;\n\t\tdirLight.shadow.camera.left = -d;\n\t\tdirLight.shadow.camera.right = d;\n\t\tdirLight.shadow.camera.top = d;\n\t\tdirLight.shadow.camera.bottom = -d;\n\t\tdirLight.shadow.camera.far = 3500;\n\t\tdirLight.shadow.bias = -0.0001;\n\t\t*/\n\t\t/*\n\t\tconst dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10);\n\t\tscene.add(dirLightHelper);\n\t\t*/\n\t}\n\n\tgetBox(parent) {\n\t\tvar geometry = new THREE.BoxGeometry(100, 100, 100);\n\t\tvar material = new THREE.MeshBasicMaterial({ color: 0x6293a9 });\n\t\tvar cube = new THREE.Mesh(geometry, material);\n\t\tparent.add(cube);\n\t\treturn cube;\n\t}\n\n\taddBoxes(parent) {\n\t\tconst boxes = new THREE.Group();\n\n\t\tlet box;\n\n\t\tfor (let i = 0; i < 12; i++) {\n\t\t\tbox = this.getBox(boxes);\n\t\t\tconst r = Math.PI * 2 / 12 * i;\n\t\t\tbox.position.set(Math.cos(r) * 300, 300, Math.sin(r) * 300);\n\t\t}\n\n\t\tfor (let i = 0; i < 12; i++) {\n\t\t\tbox = this.getBox(boxes);\n\t\t\tconst r = Math.PI * 2 / 12 * i;\n\t\t\tbox.position.set(Math.cos(r) * 300, -300, Math.sin(r) * 300);\n\t\t}\n\n\t\t/*\n\t\tbox = this.getBox(boxes);\n\t\tbox.position.set(0, -300, 0);\n\t\t*/\n\n\t\tparent.add(boxes);\n\t\treturn boxes;\n\t}\n\n\taddTau(parent) {\n\t\tconst tau = new THREE.Group();\n\t\t/*\n\t\tconst texture = new THREE.TextureLoader().load('img/matcap.jpg');\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 1,\n\t\t});\n\t\t*/\n\t\tconst texture = this.getEnvMap();\n\t\tconst clear = this.clear = this.getClear(texture);\n\t\tconst red = this.getRed(texture);\n\t\tconst loader = new THREE.OBJLoader();\n\t\tloader.load('models/tau-marin_senzaspatole_low.obj',\n\t\t\t(object) => {\n\t\t\t\tlet i = 0;\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t// console.log(child);\n\t\t\t\t\tif (child instanceof THREE.Mesh) {\n\t\t\t\t\t\tchild.geometry.scale(0.7, 0.7, 0.7);\n\t\t\t\t\t\tchild.geometry.translate(-70, 0, 0);\n\t\t\t\t\t\tchild.geometry.rotateY(Math.PI);\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tchild.material = red;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.material = clear;\n\t\t\t\t\t\t\ttau.child = child;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tconst geometry = new THREE.Geometry().fromBufferGeometry(child.geometry);\n\t\t\t\t\t\tgeometry.scale(0.01, 0.01, 0.01);\n\t\t\t\t\t\tchild.geometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// object.material = material;\n\t\t\t\tobject.rotateZ(Math.PI / 8);\n\t\t\t\tconsole.log(object);\n\t\t\t\ttau.add(object);\n\t\t\t},\n\t\t\t(xhr) => {\n\t\t\t\t// console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.log('An error happened');\n\t\t\t}\n\t\t);\n\t\tparent.add(tau);\n\t\treturn tau;\n\t}\n\n\tgetEnvMap() {\n\t\tconst textures = [\n\t\t\t'img/cubemaps/lights/',\n\t\t\t'img/cubemaps/park/',\n\t\t\t'img/cubemaps/pond/',\n\t\t\t'img/cubemaps/lake/',\n\t\t\t'img/cubemaps/square/'\n\t\t];\n\t\tconst index = 0;\n\t\tconst urls = ['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg'];\n\t\t// const texture = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping(), render);\n\t\tconst texture = new THREE.CubeTextureLoader().setPath(textures[index]).load(urls);\n\t\ttexture.mapping = THREE.CubeRefractionMapping;\n\t\t// texture.render = render;\n\t\t/*\n\t\t// Note that the second parameter has been set to new THREE.CubeRefractionMapping().  This\n\t\t// is essential for making refraction work when this texture is used as an environment map\n\t\t// on an object -- and it doesn't stop the texture from working on theskybox.\n\t\tconst shader = THREE.ShaderLib[ 'cube' ]; // contains the required shaders\n\t\tshader.uniforms[ 'tCube' ].value = texture; // data for the shaders\n\t\tconst material = new THREE.ShaderMaterial({\n\t\t\t// A ShaderMaterial uses custom vertex and fragment shaders.\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tuniforms: shader.uniforms,  // the texture is part of this object\n\t\t\tdepthWrite: false,\n\t\t\tside: THREE.BackSide\n\t\t});\n\t\t*/\n\t\treturn texture;\n\t}\n\n\tgetRed(envMap) {\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xff2222,\n\t\t\troughness: 0.1,\n\t\t\tmetalness: 0.2,\n\t\t\tenvMap: envMap,\n\t\t\t// The refractionRatio must have value in the range 0 to 1.\n\t\t\t// The default value, very close to 1, give almost invisible glass.\n\t\t\trefractionRatio: 0.1,\n\t\t\treflectivity: 0.2,\n\t\t\tside: THREE.DoubleSide,\n\t\t});\n\t\treturn material;\n\t}\n\n\t/**\n\t *  Creates the material to use on the models.  This is a MeshBasicMaterial with\n\t *  the skybox as an environment map.  The base color, which is blended with the\n\t *  environment map, is taken from the current color selection.\n\t */\n\tgetClear(envMap) {\n\n\t\tconst cubeCamera0 = this.cubeCamera0 = new THREE.CubeCamera(0.01, 1000, 512);\n\t\tcubeCamera0.renderTarget.texture.generateMipmaps = true;\n\t\tcubeCamera0.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;\n\t\tthis.scene.add(cubeCamera0);\n\n\t\tconst cubeCamera1 = this.cubeCamera1 = new THREE.CubeCamera(0.01, 1000, 512);\n\t\tcubeCamera1.renderTarget.texture.generateMipmaps = true;\n\t\tcubeCamera1.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;\n\t\tthis.scene.add(cubeCamera1);\n\n\t\tconst material = new THREE.MeshPhysicalMaterial({\n\t\t\tcolor: 0xabcbe4,\n\t\t\troughness: 0.1,\n\t\t\tmetalness: 0.9,\n\t\t\tclearCoat: 0.9,\n\t\t\tclearCoatRoughness: 0.1,\n\t\t\tenvMap: cubeCamera1.renderTarget.texture,\n\t\t\t// The refractionRatio must have value in the range 0 to 1.\n\t\t\t// The default value, very close to 1, give almost invisible glass.\n\t\t\trefractionRatio: 0.99,\n\t\t\treflectivity: 0.99,\n\t\t\t// wireframe: true,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.55,\n\t\t\t/*\n\t\t\tside: THREE.DoubleSide,\n\t\t\t*/\n\t\t});\n\t\tif (false) {\n\t\t\tmaterial.reflectivity = 0.5; // determines the fraction of light that is transmitted\n\t\t}\n\t\treturn material;\n\t}\n\n\tupdateCubeCamera() {\n\t\tif (this.tau.child) {\n\t\t\tconst renderer = this.renderer;\n\t\t\tconst scene = this.scene;\n\t\t\t// pingpong\n\t\t\tconst count = this.count,\n\t\t\t\tcubeCamera0 = this.cubeCamera0,\n\t\t\t\tcubeCamera1 = this.cubeCamera1;\n\t\t\tthis.tau.child.visible = false;\n\t\t\tthis.boxes.visible = true;\n\t\t\tif (count % 2 === 0) {\n\t\t\t\tthis.clear.envMap = cubeCamera0.renderTarget.texture;\n\t\t\t\tcubeCamera1.update(renderer, scene);\n\t\t\t} else {\n\t\t\t\tthis.clear.envMap = cubeCamera1.renderTarget.texture;\n\t\t\t\tcubeCamera0.update(renderer, scene);\n\t\t\t}\n\t\t\tthis.count = count + 1;\n\t\t\tthis.tau.child.visible = true;\n\t\t\tthis.boxes.visible = false;\n\t\t}\n\t}\n\n\t// events\n\n\tonWindowResize() {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst size = this.size;\n\t\t\tsize.width = container.offsetWidth;\n\t\t\tsize.height = container.offsetHeight;\n\t\t\tsize.aspect = size.width / size.height;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(size.width, size.height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonKeyDown(e) {\n\t\ttry {\n\t\t\t// console.log(e.which, e.key);\n\t\t\tconst key = `${e.which} ${e.key}`;\n\t\t\tthis.debugInfo.innerHTML = key;\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseDown(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.start();\n\t\t\tthis.controllers.setText('down');\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis.mousedown = true;\n\t\t\tconst raycaster = this.raycaster;\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseMove(event) {\n\t\ttry {\n\t\t\tconst w2 = this.container.offsetWidth / 2;\n\t\t\tconst h2 = this.container.offsetHeight / 2;\n\t\t\tthis.mouse = {\n\t\t\t\tx: (event.clientX - w2) / w2,\n\t\t\t\ty: -(event.clientY - h2) / h2,\n\t\t\t};\n\t\t\tconst raycaster = this.raycaster;\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t\tInteractiveMesh.hittest(raycaster, this.mousedown);\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseUp(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.end();\n\t\t\tthis.controllers.setText('up');\n\t\t\treturn;\n\t\t}\n\t\tthis.mousedown = false;\n\t}\n\n\tonMouseWheel(event) {\n\t\ttry {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = camera.fov + event.deltaY * 0.01;\n\t\t\tcamera.fov = THREE.Math.clamp(fov, 30, 75);\n\t\t\tcamera.updateProjectionMatrix();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonSave(event) {\n\t\ttry {\n\t\t\tthis.view.orientation = this.orbit.getOrientation();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\t// animation\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() => {\n\t\t\tthis.render();\n\t\t});\n\t}\n\n\trender(delta) {\n\t\tconst controls = this.controls;\n\t\tcontrols.update();\n\t\tconst renderer = this.renderer;\n\t\tconst camera = this.camera;\n\t\tconst scene = this.scene;\n\t\tthis.updateCubeCamera();\n\t\trenderer.render(scene, camera);\n\t}\n\n\tupdateCamera() {\n\t\tconst orbit = this.orbit;\n\t\tconst camera = this.camera;\n\t\torbit.update();\n\t\tcamera.target.x = ROOM_RADIUS * Math.sin(orbit.phi) * Math.cos(orbit.theta);\n\t\tcamera.target.y = ROOM_RADIUS * Math.cos(orbit.phi);\n\t\tcamera.target.z = ROOM_RADIUS * Math.sin(orbit.phi) * Math.sin(orbit.theta);\n\t\tcamera.lookAt(camera.target);\n\t\t/*\n\t\t// distortion\n\t\tcamera.position.copy( camera.target ).negate();\n\t\t*/\n\t}\n\n\t// utils\n\n\tsaveData(data, filename = 'console.json') {\n\t\tif (!data) {\n\t\t\tconsole.error('Console.save: No data');\n\t\t\treturn;\n\t\t}\n\t\tif (typeof data === 'object') {\n\t\t\tdata = JSON.stringify(data, undefined, 4);\n\t\t}\n\t\tconst blob = new Blob([data], { type: 'text/json' });\n\t\tconst event = document.createEvent('MouseEvents');\n\t\tconst anchor = document.createElement('a');\n\t\tanchor.download = filename;\n\t\tanchor.href = window.URL.createObjectURL(blob);\n\t\tanchor.dataset.downloadurl = ['text/json', anchor.download, anchor.href].join(':');\n\t\tevent.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\tanchor.dispatchEvent(event);\n\t}\n\n}\n\nconst tau = new Tau();\n/*\nconst textureLoader = new THREE.TextureLoader();\ntextureLoader.load('img/panorama-sm/panorama-01.jpg', (texture) => {\n\ttexture.mapping = THREE.UVMapping;\n\tvar options = {\n\t\tresolution: 1024,\n\t\tgenerateMipmaps: true,\n\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\tmagFilter: THREE.LinearFilter\n\t};\n\ttau.scene.background = new THREE.CubemapGenerator(tau.renderer).fromEquirectangular(texture, options);\n\ttau.animate();\n});\n*/\n// tau.load('data/vr.json');\ntau.animate();\n"],"file":"docs/js/tau.js"}