{"version":3,"names":[],"mappings":"","sources":["src/js/tau.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, THREE, WEBVR */\n\nimport { ROOM_RADIUS, TEST_ENABLED } from './three/const';\nimport InteractiveMesh from './three/interactive.mesh';\nimport Orbit from './three/orbit';\n\nconst USE_CUBE_CAMERA = true;\nconst COLORS = [0xFFFFFF, 0xFC4445, 0xFEEE6, 0x55BCC9, 0x97CAEF, 0xCAFAFE];\n\nclass Tau {\n\n\tconstructor() {\n\t\tthis.colorIndex = 0;\n\t\tthis.count = 0;\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t\tthis.cameraDirection = new THREE.Vector3();\n\t\tthis.init();\n\t}\n\n\t/*\n\tload(jsonUrl) {\n\t\ttry {\n\t\t\tfetch(jsonUrl).then(response => response.json()).then(response => {\n\t\t\t\tthis.pivot.views = response.views;\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\t*/\n\n\tinit() {\n\t\tconst body = this.body = document.querySelector('body');\n\t\tconst section = this.section = document.querySelector('.tau');\n\t\tconst container = this.container = section.querySelector('.tau__container');\n\t\tconst debugInfo = this.debugInfo = section.querySelector('.debug__info');\n\t\tconst debugSave = this.debugSave = section.querySelector('.debug__save');\n\t\t// Dom.detect(body);\n\t\t// body.classList.add('ready');\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onKeyDown = this.onKeyDown.bind(this);\n\t\tthis.onMouseDown = this.onMouseDown.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onMouseUp = this.onMouseUp.bind(this);\n\t\tthis.onMouseWheel = this.onMouseWheel.bind(this);\n\t\tthis.onSave = this.onSave.bind(this);\n\t\t//\n\t\tconst scene = this.scene = this.addScene();\n\t\tconst camera = this.camera = this.addCamera();\n\t\tconst lights = this.lights = this.addLights(scene);\n\t\t// const addons = this.addons = this.addBoxes(scene);\n\t\tconst addons = this.addons = this.addSpheres(scene);\n\t\tconst hdr = this.hdr = this.getEnvMap((texture, textureData) => {\n\t\t\tconst tau = this.tau = this.addTau(scene, texture);\n\t\t\tthis.tweenTau();\n\t\t});\n\t\tconst renderer = this.renderer = this.addRenderer();\n\t\t/*\n\t\t// camera.target.z = ROOM_RADIUS;\n\t\t// camera.lookAt(camera.target);\n\t\tconst controls = this.controls = new THREE.OrbitControls(camera, renderer.domElement);\n\t\tcontrols.maxDistance = 250;\n\t\tcontrols.minDistance = 100;\n\t\t// controls.maxPolarAngle = Math.PI / 2;\n\t\t// controls.minPolarAngle = Math.PI / 2;\n\t\t// camera.position.set(60, 205, -73);\n        // camera.position.set(0, 50, 100);\n\t\tcamera.position.set(6.3, 4.5, 111.5);\n\t\tcamera.position.multiplyScalar(1.5);\n\t\tcontrols.update();\n        */\n\t\tcamera.position.set(0, 0, 150);\n\t\tconst orbit = this.orbit = new Orbit();\n\t\tconst dragListener = this.dragListener = orbit.setDragListener(container);\n\t\t// raycaster\n\t\tconst raycaster = this.raycaster = new THREE.Raycaster();\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\t/*\n\t\twindow.addEventListener('keydown', this.onKeyDown, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\t\tdocument.addEventListener('wheel', this.onMouseWheel, false);\n\t\tthis.container.addEventListener('mousedown', this.onMouseDown, false);\n\t\tthis.container.addEventListener('mouseup', this.onMouseUp, false);\n        this.debugSave.addEventListener('click', this.onSave, false);\n        */\n\t\tthis.section.classList.add('init');\n\t\tthis.onWindowResize();\n\t\t// this.updateBackgroundColor();\n\t}\n\n\tupdateBackgroundColor() {\n\t\tthis.colorIndex++;\n\t\tthis.colorIndex = this.colorIndex % COLORS.length;\n\t\tconst color = COLORS[this.colorIndex];\n\t\t/*\n\t\tconst r = Math.floor(Math.random() * 255);\n\t\tconst g = Math.floor(Math.random() * 255);\n\t\tconst b = Math.floor(Math.random() * 255);\n\t\t*/\n\t\tTweenMax.to(this.renderer.domElement, 0.7, {\n\t\t\tbackgroundColor: color, // `rgba(${r},${g},${b},1)`,\n\t\t\tdelay: 3,\n\t\t\tease: Power2.easeInOut,\n\t\t\tonUpdate: () => {\n\t\t\t\tthis.addons.children.forEach(x => {\n\t\t\t\t\tx.material.color.setHex(color);\n\t\t\t\t\tx.material.needsUpdate = true;\n\t\t\t\t});\n\t\t\t},\n\t\t\tonComplete: () => {\n\t\t\t\tthis.updateBackgroundColor();\n\t\t\t}\n\t\t});\n\t}\n\n\taddRenderer() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\tantialias: true,\n\t\t\t// localClippingEnabled: true,\n\t\t\t// logarithmicDepthBuffer: true,\n\t\t\t// premultipliedAlpha: true,\n\t\t\talpha: true,\n\t\t});\n\t\tthis.renderer = renderer;\n\t\t// renderer.shadowMap.enabled = true;\n\t\trenderer.setClearColor(0xffffff, 0);\n\t\t// renderer.setPixelRatio(window.devicePixelRatio);\n\t\trenderer.setPixelRatio(1.5);\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\t\treturn renderer;\n\t}\n\n\taddScene() {\n\t\tconst scene = new THREE.Scene();\n\t\t// scene.background = new THREE.Color(0x00000000);\n\t\t// scene.background = new THREE.Color(0x404040);\n\t\t// scene.fog = new THREE.Fog(scene.background, 10, 700);\n\t\treturn scene;\n\t}\n\n\taddCamera() {\n\t\tconst camera = new THREE.PerspectiveCamera(8, window.innerWidth / window.innerHeight, 0.01, 2000);\n\t\tcamera.zoom = 0.15;\n\t\tcamera.target = new THREE.Vector3();\n\t\treturn camera;\n\t}\n\n\taddLights(scene) {\n\t\tconst lights = new THREE.Group();\n\n\t\tconst hemiLight = new THREE.HemisphereLight(0xf4fbfb, 0x91978a, 0.6);\n\t\themiLight.position.set(0, 0, 0);\n\t\tscene.add(hemiLight);\n\n\t\t/*\n\t\tconst hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 10);\n\t\tscene.add(hemiLightHelper);\n\t\t*/\n\t\tconst light1 = new THREE.DirectionalLight(0xffffff, 1);\n\t\tlight1.position.set(-50, 100, 0);\n\t\tlights.add(light1);\n\n\t\t/*\n\t\tconst light2 = new THREE.DirectionalLight(0xffffff, 0.9);\n\t\tlight2.position.set(0, 30, 0);\n\t\tlights.add(light2);\n\n\t\tconst light3 = new THREE.DirectionalLight(0xffffff, 0.9);\n\t\tlight3.position.set(60, 5, -50);\n\t\tlights.add(light3);\n        */\n\n\t\t/*\n\t\tconst geometry = new THREE.BoxGeometry(2, 2, 2);\n\t\tconst material = new THREE.MeshBasicMaterial({ color: 0xafb3bc });\n\t\tconst cube = new THREE.Mesh(geometry, material);\n\t\tcube.position.set(0, 2, 0);\n\t\tthis.scene.add(cube);\n\t\t*/\n\n\t\t/*\n\t\tconst light4 = new THREE.DirectionalLight(0xffffff, 0.8);\n\t\tlight4.position.set(50, -100, -50);\n\t\tlights.add(light4);\n\t\t*/\n\n\t\t/*\n\t\tdirLight.castShadow = true;\n\t\tdirLight.shadow.mapSize.width = 2048;\n\t\tdirLight.shadow.mapSize.height = 2048;\n\t\tconst d = 50;\n\t\tdirLight.shadow.camera.left = -d;\n\t\tdirLight.shadow.camera.right = d;\n\t\tdirLight.shadow.camera.top = d;\n\t\tdirLight.shadow.camera.bottom = -d;\n\t\tdirLight.shadow.camera.far = 3500;\n\t\tdirLight.shadow.bias = -0.0001;\n\t\t*/\n\t\t/*\n\t\tconst dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10);\n\t\tscene.add(dirLightHelper);\n\t\t*/\n\t\tscene.add(lights);\n\t\treturn lights;\n\t}\n\n\taddBox(parent) {\n\t\tconst geometry = new THREE.BoxGeometry(600, 30, 30);\n\t\tconst material = new THREE.MeshBasicMaterial({ color: 0xafb3bc });\n\t\tconst cube = new THREE.Mesh(geometry, material);\n\t\tparent.add(cube);\n\t\treturn cube;\n\t}\n\n\taddBoxes(parent) {\n\t\tconst group = new THREE.Group();\n\t\tgroup.visible = true;\n\t\tconst boxes = new Array(12).fill(null).map((x, i) => {\n\t\t\tconst box = this.addBox(group);\n\t\t\tconst r = Math.PI * 2 / 12 * i;\n\t\t\tbox.position.set(0, Math.sin(r) * 300, Math.cos(r) * 300);\n\t\t\treturn box;\n\t\t});\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddSpheres(parent) {\n\t\tconst group = new THREE.Group();\n\t\tgroup.visible = false;\n\t\tconst icosahedron = new THREE.IcosahedronGeometry(300, 1);\n\t\tconst geometry = new THREE.Geometry();\n\t\ticosahedron.vertices.forEach((v, i) => {\n\t\t\tconst sphereGeometry = new THREE.SphereGeometry(30, 12, 12);\n\t\t\tsphereGeometry.translate(v.x, v.y, v.z);\n\t\t\tgeometry.merge(sphereGeometry);\n\t\t\tsphereGeometry.dispose();\n\t\t});\n\t\ticosahedron.dispose();\n\t\tconst material = new THREE.MeshBasicMaterial({ color: 0x9196a1 });\n\t\tconst bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n\t\tgeometry.dispose();\n\t\tconst spheres_ = new THREE.Mesh(bufferGeometry, material);\n\t\tgroup.add(spheres_);\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddTau(parent, texture) {\n\t\tconst tau = new THREE.Group();\n\t\t/*\n\t\tconst texture = new THREE.loader().load('img/matcap.jpg');\n\t\tconst material = new THREE.MeshMatcapMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\tmatcap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 1,\n\t\t});\n\t\t*/\n\t\t// const texture = this.getEnvMap();\n\t\tthis.getCubeCamera();\n\t\t// const texture = this.cubeCamera1.renderTarget.texture;\n\t\tconst clear = this.clear = this.getClear(texture);\n\t\tconst silver = this.silver = this.getSilver(texture);\n\t\tconst red = this.red = this.getRed(texture);\n\t\tconst blue = this.blue = this.getBlue();\n\t\tconst green = this.green = this.getGreen();\n\t\tconst loader = new THREE.OBJLoader();\n\t\tloader.load(\n\t\t\t'models/tau-marin_2.obj',\n\t\t\t// 'models/scalare-33-b/scalare-33-b.obj',\n\t\t\t(object) => {\n\t\t\t\tlet i = 0;\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t// console.log(child);\n\t\t\t\t\tif (child instanceof THREE.Mesh) {\n\t\t\t\t\t\tchild.geometry.scale(10, 10, 10);\n\t\t\t\t\t\t// child.geometry.rotateX(-Math.PI / 2);\n\t\t\t\t\t\t// child.geometry.computeVertexNormals(true);\n\t\t\t\t\t\t// child.geometry.computeTangents();\n\t\t\t\t\t\tTHREE.BufferGeometryUtils.computeTangents(child.geometry);\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tchild.material = red;\n\t\t\t\t\t\t} else if (i === 1) {\n\t\t\t\t\t\t\tchild.material = clear;\n\t\t\t\t\t\t\ttau.body = child;\n\t\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t\tchild.material = clear;\n\t\t\t\t\t\t\ttau.body = child;\n\t\t\t\t\t\t} else if (i === 3) {\n\t\t\t\t\t\t\tchild.material = silver;\n\t\t\t\t\t\t} else if (i === 4) {\n\t\t\t\t\t\t\tchild.material = silver;\n\t\t\t\t\t\t} else if (i === 5) {\n\t\t\t\t\t\t\tchild.material = silver;\n\t\t\t\t\t\t} else if (i === 6) {\n\t\t\t\t\t\t\tchild.material = green;\n\t\t\t\t\t\t} else if (i === 7) {\n\t\t\t\t\t\t\tchild.material = blue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tchild.geometry.scale(150, 150, 150);\n\t\t\t\t\t\tchild.geometry.rotateX(-Math.PI / 2);\n\t\t\t\t\t\t// child.geometry.computeVertexNormals(true);\n\t\t\t\t\t\t// child.geometry.computeTangents();\n\t\t\t\t\t\tTHREE.BufferGeometryUtils.computeTangents(child.geometry);\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tchild.material = red;\n\t\t\t\t\t\t} else if (i === 1) {\n\t\t\t\t\t\t\tchild.material = green;\n\t\t\t\t\t\t} else if (i === 2) {\n\t\t\t\t\t\t\tchild.material = blue;\n\t\t\t\t\t\t} else if (i === 3) {\n\t\t\t\t\t\t\tchild.material = clear;\n\t\t\t\t\t\t\ttau.body = child;\n                        }\n                        */\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// this.addLogo(object);\n\t\t\t\t// object.material = material;\n\t\t\t\t// object.rotateZ(Math.PI / 8);\n\t\t\t\tconsole.log(object);\n\t\t\t\ttau.add(object);\n\t\t\t},\n\t\t\t(xhr) => {\n\t\t\t\t// console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );\n\t\t\t},\n\t\t\t(error) => {\n\t\t\t\tconsole.log('An error happened');\n\t\t\t}\n\t\t);\n\t\tparent.add(tau);\n\t\treturn tau;\n\t}\n\n\ttweenTau() {\n\t\tconst rotations = [\n            [Math.PI / 4, Math.PI / 4, Math.PI / 4],\n            [Math.PI / 4, Math.PI - Math.PI / 4, Math.PI / 4],\n            [0, 0, Math.PI / 2],\n            [Math.PI / 2, 0, 0],\n            [Math.PI / 4, Math.PI / 4, 0],\n            [0, -Math.PI / 2, Math.PI / 16]\n        ];\n\t\tconst tau = this.tau;\n\t\tlet ri = tau.ri !== undefined ? tau.ri : -1;\n\t\tri++;\n\t\tri = ri % rotations.length;\n\t\ttau.ri = ri;\n\t\tconsole.log(tau, ri);\n\t\tconst rotation = rotations[ri];\n\t\tTweenMax.to(this.tau.rotation, 0.7, {\n\t\t\tx: rotation[0],\n\t\t\ty: rotation[1],\n\t\t\tz: rotation[2],\n\t\t\tdelay: 4,\n\t\t\tonComplete: () => {\n\t\t\t\tthis.tweenTau();\n\t\t\t}\n\t\t});\n\t}\n\n\taddLogo(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(24, 3, 3, 1);\n\t\tgeometry.rotateX(-Math.PI / 2);\n\t\tgeometry.translate(20, 2, 0);\n\t\tgeometry.rotateY(Math.PI);\n\t\t// geometry.translate(0, 2.2, -24);\n\t\tconst logo = new THREE.Mesh(geometry, this.silver);\n\t\tparent.add(logo);\n\t\treturn logo;\n\t}\n\n\tgetCubeCamera() {\n\t\tif (USE_CUBE_CAMERA) {\n\t\t\tconst cubeCamera0 = this.cubeCamera0 = new THREE.CubeCamera(0.01, 1000, 512);\n\t\t\tcubeCamera0.renderTarget.texture.generateMipmaps = true;\n\t\t\tcubeCamera0.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\tthis.scene.add(cubeCamera0);\n\t\t\tconst cubeCamera1 = this.cubeCamera1 = new THREE.CubeCamera(0.01, 1000, 512);\n\t\t\tcubeCamera1.renderTarget.texture.generateMipmaps = true;\n\t\t\tcubeCamera1.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;\n\t\t\tthis.scene.add(cubeCamera1);\n\t\t}\n\t}\n\n\tgetEnvMap_(callback) {\n\t\tconst textures = [\n\t\t\t'img/cubemaps/lights/',\n\t\t\t'img/cubemaps/park/',\n\t\t\t'img/cubemaps/pond/',\n\t\t\t'img/cubemaps/lake/',\n\t\t\t'img/cubemaps/square/'\n\t\t];\n\t\tconst index = 0;\n\t\tconst urls = ['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg'];\n\t\t// const texture = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping(), render);\n\t\tconst loader = new THREE.CubeTextureLoader().setPath(textures[index]).load(urls, (texture, textureData) => {\n\t\t\ttexture.mapping = THREE.CubeRefractionMapping;\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tcallback(texture, textureData);\n\t\t\t}\n\t\t});\n\t\treturn loader;\n\t}\n\n\tgetEnvMap(callback) {\n\t\tconst loader = new THREE.TextureLoader().load('img/hdr-04.jpg', (source, textureData) => {\n\t\t\t// source.encoding = THREE.sRGBEncoding;\n\t\t\tsource.mapping = THREE.UVMapping;\n\t\t\tconst options = {\n\t\t\t\tresolution: 1024,\n\t\t\t\tgenerateMipmaps: true,\n\t\t\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter\n\t\t\t};\n\t\t\t// this.scene.background = new THREE.CubemapGenerator(this.renderer).fromEquirectangular(source, options);\n\t\t\tconst cubemapGenerator = new THREE.EquirectangularToCubeGenerator(source, options);\n\t\t\t// pngBackground = cubemapGenerator.renderTarget;\n\t\t\tconst texture = cubemapGenerator.update(this.renderer);\n\t\t\t/*\n\t\t\tvar pmremGenerator = new THREE.PMREMGenerator( cubeMapTexture );\n\t\t\tpmremGenerator.update( renderer );\n\t\t\tvar pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );\n\t\t\tpmremCubeUVPacker.update( renderer );\n\t\t\tpngCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;\n\t\t\t*/\n\t\t\tsource.dispose();\n\t\t\t/*\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremCubeUVPacker.dispose();\n\t\t\t*/\n\t\t\ttexture.mapping = THREE.CubeReflectionMapping;\n\t\t\ttexture.mapping = THREE.CubeRefractionMapping;\n\t\t\t/*\n\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t*/\n\t\t\t// texture.generateMipmaps = false;\n\t\t\t// texture.flipY = true;\n\t\t\t// this.renderer.toneMappingExposure = 2.0;\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tcallback(texture);\n\t\t\t}\n\t\t});\n\t\t//\n\t\treturn loader;\n\t}\n\n\tgetHDRMap(callback) {\n\t\tconst type = THREE.UnsignedByteType;\n\t\t// const type = THREE.FloatType;\n\t\tconst loader = new THREE.RGBELoader().setType(type).load('img/hdr/studio_small_02_1k.hdr', (source, sourceData) => {\n\t\t\tswitch (type) {\n\t\t\t\tcase THREE.UnsignedByteType:\n\t\t\t\t\tsource.encoding = THREE.RGBEEncoding;\n\t\t\t\t\tsource.minFilter = THREE.NearestFilter;\n\t\t\t\t\tsource.magFilter = THREE.NearestFilter;\n\t\t\t\t\tbreak;\n\t\t\t\tcase THREE.FloatType:\n\t\t\t\t\tsource.encoding = THREE.LinearEncoding;\n\t\t\t\t\tsource.minFilter = THREE.LinearFilter;\n\t\t\t\t\tsource.magFilter = THREE.LinearFilter;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsource.generateMipmaps = false;\n\t\t\tsource.flipY = true;\n\n\t\t\tconst cubemapGenerator = new THREE.EquirectangularToCubeGenerator(source, { resolution: 512 });\n\t\t\tthis.renderer.toneMappingExposure = 2.0;\n\t\t\tconst texture = cubemapGenerator.update(this.renderer);\n\n\t\t\tsource.dispose();\n\n\t\t\tif (typeof callback === 'function') {\n\t\t\t\tcallback(texture);\n\t\t\t}\n\t\t});\n\t\t//\n\t\treturn loader;\n\t}\n\n\tgetBlue(texture) {\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0x0007d8,\n\t\t\t// emissive: 0x000066,\n\t\t\troughness: 0.3,\n\t\t\tmetalness: 0.0,\n\t\t});\n\t\treturn material;\n\t}\n\n\tgetGreen(texture) {\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0x00d84d,\n\t\t\t// emissive: 0x006600,\n\t\t\troughness: 0.3,\n\t\t\tmetalness: 0.0,\n\t\t});\n\t\treturn material;\n\t}\n\n\tgetRed(texture) {\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xe11e26,\n\t\t\temissive: 0x4f0300,\n\t\t\troughness: 0.2,\n\t\t\tmetalness: 0.2,\n\t\t\tenvMap: texture,\n\t\t\tenvMapIntensity: 0.4,\n\t\t\t// The refractionRatio must have value in the range 0 to 1.\n\t\t\t// The default value, very close to 1, give almost invisible glass.\n\t\t\trefractionRatio: 0,\n\t\t\tside: THREE.DoubleSide,\n\t\t});\n\t\treturn material;\n\t}\n\n\tgetClear(texture) {\n\t\tconst material = new THREE.MeshBasicMaterial({\n\t\t\tcolor: 0xffffff,\n\t\t\trefractionRatio: 0.99,\n\t\t\treflectivity: 0.99,\n\t\t\tenvMap: texture,\n\t\t\tenvMapIntensity: 2.0,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tside: THREE.DoubleSide,\n\t\t\t// blending: THREE.AdditiveBlending,\n\t\t});\n\t\treturn material;\n\t}\n\n\tgetSilver(texture) {\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xaaaaaa,\n\t\t\troughness: 0.2,\n\t\t\tmetalness: 0.99,\n\t\t\tenvMap: texture,\n\t\t\trefractionRatio: 0.0,\n\t\t\treflectivity: 0.9,\n\t\t\tside: THREE.DoubleSide,\n\t\t});\n\t\treturn material;\n\t}\n\n\tupdateCubeCamera() {\n\t\tif (USE_CUBE_CAMERA && this.tau && this.tau.body) {\n\t\t\tconst renderer = this.renderer;\n\t\t\tconst scene = this.scene;\n\t\t\t// pingpong\n\t\t\tconst count = this.count,\n\t\t\t\tcubeCamera0 = this.cubeCamera0,\n\t\t\t\tcubeCamera1 = this.cubeCamera1;\n\t\t\trenderer.setClearColor(0xffffff, 1);\n\t\t\tthis.tau.body.visible = false;\n\t\t\tthis.addons.visible = true;\n\t\t\tif (count % 2 === 0) {\n\t\t\t\tthis.clear.envMap = cubeCamera0.renderTarget.texture;\n\t\t\t\tthis.silver.envMap = cubeCamera0.renderTarget.texture;\n\t\t\t\tthis.red.envMap = cubeCamera0.renderTarget.texture;\n\t\t\t\tcubeCamera1.update(renderer, scene);\n\t\t\t} else {\n\t\t\t\tthis.clear.envMap = cubeCamera1.renderTarget.texture;\n\t\t\t\tthis.silver.envMap = cubeCamera1.renderTarget.texture;\n\t\t\t\tthis.red.envMap = cubeCamera1.renderTarget.texture;\n\t\t\t\tcubeCamera0.update(renderer, scene);\n\t\t\t}\n\t\t\tthis.count = count + 1;\n\t\t\tthis.tau.body.visible = true;\n\t\t\tthis.addons.visible = false;\n\t\t\trenderer.setClearColor(0xffffff, 0);\n\t\t}\n\t}\n\n\t// events\n\n\tonWindowResize() {\n\t\ttry {\n\t\t\tconst container = this.container,\n\t\t\t\trenderer = this.renderer,\n\t\t\t\tcamera = this.camera;\n\t\t\tconst size = this.size;\n\t\t\tsize.width = container.offsetWidth;\n\t\t\tsize.height = container.offsetHeight;\n\t\t\tsize.aspect = size.width / size.height;\n\t\t\tif (renderer) {\n\t\t\t\trenderer.setSize(size.width, size.height);\n\t\t\t}\n\t\t\tif (camera) {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonKeyDown(e) {\n\t\ttry {\n\t\t\t// console.log(e.which, e.key);\n\t\t\tconst key = `${e.which} ${e.key}`;\n\t\t\tthis.debugInfo.innerHTML = key;\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseDown(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.start();\n\t\t\tthis.controllers.setText('down');\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tthis.mousedown = true;\n\t\t\tconst raycaster = this.raycaster;\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseMove(event) {\n\t\ttry {\n\t\t\tconst w2 = this.container.offsetWidth / 2;\n\t\t\tconst h2 = this.container.offsetHeight / 2;\n\t\t\tthis.mouse = {\n\t\t\t\tx: (event.clientX - w2) / w2,\n\t\t\t\ty: -(event.clientY - h2) / h2,\n\t\t\t};\n\t\t\tconst raycaster = this.raycaster;\n\t\t\traycaster.setFromCamera(this.mouse, this.camera);\n\t\t\tInteractiveMesh.hittest(raycaster, this.mousedown);\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonMouseUp(event) {\n\t\tif (TEST_ENABLED) {\n\t\t\t// this.dragListener.end();\n\t\t\tthis.controllers.setText('up');\n\t\t\treturn;\n\t\t}\n\t\tconsole.log(this.camera.position);\n\t\tthis.mousedown = false;\n\t}\n\n\tonMouseWheel(event) {\n\t\ttry {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = camera.fov + event.deltaY * 0.01;\n\t\t\tcamera.fov = THREE.Math.clamp(fov, 30, 75);\n\t\t\tcamera.updateProjectionMatrix();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\tonSave(event) {\n\t\ttry {\n\t\t\tthis.view.orientation = this.orbit.getOrientation();\n\t\t} catch (error) {\n\t\t\tthis.debugInfo.innerHTML = error;\n\t\t}\n\t}\n\n\t// animation\n\n\tanimate() {\n\t\tconst renderer = this.renderer;\n\t\trenderer.setAnimationLoop(() => {\n\t\t\tthis.render();\n\t\t});\n\t}\n\n\trender(delta) {\n\t\tconst controls = this.controls;\n\t\tif (controls) {\n\t\t\tcontrols.update();\n\t\t}\n\t\t// this.lights.rotation.set(0, this.lights.rotation.y + 0.003, 0);\n\t\t// this.tau.rotation.set(Math.cos(this.count / 100) * Math.PI / 180 * 2, Math.cos(this.count / 100) * Math.PI / 180 * 2, 0);\n\t\tconst renderer = this.renderer;\n\t\tconst camera = this.camera;\n\t\tconst scene = this.scene;\n\t\tthis.updateCubeCamera();\n\t\trenderer.render(scene, camera);\n\t}\n\n\tupdateCamera() {\n\t\tconst orbit = this.orbit;\n\t\tconst camera = this.camera;\n\t\torbit.update();\n\t\tcamera.target.x = ROOM_RADIUS * Math.sin(orbit.phi) * Math.cos(orbit.theta);\n\t\tcamera.target.y = ROOM_RADIUS * Math.cos(orbit.phi);\n\t\tcamera.target.z = ROOM_RADIUS * Math.sin(orbit.phi) * Math.sin(orbit.theta);\n\t\tcamera.lookAt(camera.target);\n\t\t/*\n\t\t// distortion\n\t\tcamera.position.copy( camera.target ).negate();\n\t\t*/\n\t}\n\n\t// utils\n\n\tsaveData(data, filename = 'console.json') {\n\t\tif (!data) {\n\t\t\tconsole.error('Console.save: No data');\n\t\t\treturn;\n\t\t}\n\t\tif (typeof data === 'object') {\n\t\t\tdata = JSON.stringify(data, undefined, 4);\n\t\t}\n\t\tconst blob = new Blob([data], { type: 'text/json' });\n\t\tconst event = document.createEvent('MouseEvents');\n\t\tconst anchor = document.createElement('a');\n\t\tanchor.download = filename;\n\t\tanchor.href = window.URL.createObjectURL(blob);\n\t\tanchor.dataset.downloadurl = ['text/json', anchor.download, anchor.href].join(':');\n\t\tevent.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\tanchor.dispatchEvent(event);\n\t}\n\n}\n\nconst tau = new Tau();\n/*\nconst loader = new THREE.loader();\nloader.load('img/panorama-sm/panorama-01.jpg', (texture) => {\n\ttexture.mapping = THREE.UVMapping;\n\tconst options = {\n\t\tresolution: 1024,\n\t\tgenerateMipmaps: true,\n\t\tminFilter: THREE.LinearMipMapLinearFilter,\n\t\tmagFilter: THREE.LinearFilter\n\t};\n\ttau.scene.background = new THREE.CubemapGenerator(tau.renderer).fromEquirectangular(texture, options);\n\ttau.animate();\n});\n*/\n// tau.load('data/vr.json');\ntau.animate();\n"],"file":"docs/js/tau.js"}